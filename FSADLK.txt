#include <iostream>
#include <random>
#include <string>

int playerNumGenerator(int);
int playerDataGenerator(int);
char playerColor(int);
int boardGenerator();
int main();
int playerMovement(int, int);
bool checkValidOrKillMovement(int, int);
void sliderKillCheck(char, int);
bool sliderCheckAndMove(int, int);
int cardDraw();
char playerColorTurn(int);
int playerMovementInput(char);
bool checkIfPlayerWon(char);
void sorryCardActivation(char, int);
void swapPosition(char);
bool userSwapOrMove(char);
void displayBoard();
char gamePlayingFunction();

int playerCount = 2;
char teamColor[] = { 'r', 'b', 'g', 'y' };
int pieceIdentifier[16] = { 999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999 };
int piecePosition[16] = { 999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999 };
int sliders[] = { 57, 0, 5, 9,     12, 15, 20, 24,         27, 30, 35, 39,           42, 45, 50, 54 };
int gameBoard[84] = {};
int one(5), two(4), three(4), four(4), five(4), six(4), seven(4), eight(4), nine(4), ten(4), eleven(4), twelve(4), sorry(4); //cardAmounts


int playerNumGenerator(int a) { //generates a number of each piece based off the numbers of players
	static int pieceNumber = 0;
	pieceIdentifier[a] = pieceNumber;
	pieceNumber++;
	return 0;
}
char playerColor(int pieceNum) { //function used to determine the color of a piece
	return teamColor[pieceNum / 4];
}
int playerDataGenerator(int playerCount) { //Function that will load all data necessary for the game
	for (int a = 0; a < (playerCount * 4); a++) { //Generates the player pieces and assigns them to their base
		playerNumGenerator(a);
		switch (playerColor(a)) {
		case 'r':
			piecePosition[a] = -1;
			break;
		case 'b':
			piecePosition[a] = -2;
			break;
		case 'g':
			piecePosition[a] = -3;
			break;
		case 'y':
			piecePosition[a] = -4;
			break;
		}
	}


	return 0;
}
int boardGenerator() { //Generates a board (I think this may be useless honestly)
	int b = 0;
	do {
		static int a = 0;
		gameBoard[a] = a;
		a++;
		b++;
	} while (b < 84);
	return 0;
}
int playerMovement(int pieceNumber, int movementLeft) { //This function will move the pieces and check validity with other functions (the movement function)
	int originalPositionForIllegalReset = piecePosition[pieceNumber];
	if (piecePosition[pieceNumber] == 66 || piecePosition[pieceNumber] == 72 || piecePosition[pieceNumber] == 78 || piecePosition[pieceNumber] == 84) {
		movementLeft = 0;
	}
	if (movementLeft == 13) {
		movementLeft = 0;
		sorryCardActivation(playerColor(pieceNumber), pieceNumber);
	}
	if (movementLeft == 4) {
		movementLeft = -4;
	}

	if (piecePosition[pieceNumber] == -1 || piecePosition[pieceNumber] == -2 || piecePosition[pieceNumber] == -3 || piecePosition[pieceNumber] == -4) {
		if (movementLeft == 1 || movementLeft == 2) {
			movementLeft = 0;
			switch (playerColor(pieceNumber)) {
			case 'r':
				if (checkValidOrKillMovement(1, pieceNumber)) {
					piecePosition[pieceNumber] = 1;
				}
				break;
			case 'b':
				if (checkValidOrKillMovement(16, pieceNumber)) {
					piecePosition[pieceNumber] = 16;
				}
				break;
			case 'g':
				if (checkValidOrKillMovement(31, pieceNumber)) {
					piecePosition[pieceNumber] = 31;
				}
				break;
			case 'y':
				if (checkValidOrKillMovement(46, pieceNumber)) {
					piecePosition[pieceNumber] = 46;
				}
				break;
			}
		}
		else {
			movementLeft = 0;
		}
	}
	if (movementLeft > 0) {
		for (int x = 0; x < movementLeft; x++) {
			piecePosition[pieceNumber] += 1;
			switch (playerColor(pieceNumber)) {
			case 'r':
				if (piecePosition[pieceNumber] == 59 && playerColor(pieceNumber) == 'r') {
					piecePosition[pieceNumber] = 61;
				}
				break;
			case 'b':
				if (piecePosition[pieceNumber] == 14 && playerColor(pieceNumber) == 'b') {
					piecePosition[pieceNumber] = 67;
				}
				break;
			case 'g':
				if (piecePosition[pieceNumber] == 29 && playerColor(pieceNumber) == 'g') {
					piecePosition[pieceNumber] = 73;
				}
				break;
			case 'y':
				if (piecePosition[pieceNumber] == 44 && playerColor(pieceNumber) == 'y') {
					piecePosition[pieceNumber] = 79;
				}
				break;
			}
			if (piecePosition[pieceNumber] == 59) {
				piecePosition[pieceNumber] = 0;
			}
			if (piecePosition[pieceNumber] == 66 || piecePosition[pieceNumber] == 72 || piecePosition[pieceNumber] == 78 || piecePosition[pieceNumber] == 84) {
				movementLeft = 0;
			}
		}
	}
	else if (movementLeft < 0) {
		for (int x = 0; x > movementLeft; x--) {
			piecePosition[pieceNumber] -= 1;
			switch (playerColor(pieceNumber)) {
			case 'r':
				if (piecePosition[pieceNumber] == 60) {
					piecePosition[pieceNumber] = 58;
				}
			case 'b':
				if (piecePosition[pieceNumber] == 66) {
					piecePosition[pieceNumber] = 13;
				}
			case 'g':
				if (piecePosition[pieceNumber] == 29) {
					piecePosition[pieceNumber] = 28;
				}
			case 'y':
				if (piecePosition[pieceNumber] == 78) {
					piecePosition[pieceNumber] = 43;
				}
			}
			if (piecePosition[pieceNumber] == -1) {
				piecePosition[pieceNumber] = 59;
			}
		}
	}
	if (piecePosition[pieceNumber] == 57 || piecePosition[pieceNumber] == 5 || piecePosition[pieceNumber] == 12 || piecePosition[pieceNumber] == 20 || piecePosition[pieceNumber] == 27 || piecePosition[pieceNumber] == 35 || piecePosition[pieceNumber] == 42 || piecePosition[pieceNumber] == 50) {
		if (!(sliderCheckAndMove(piecePosition[pieceNumber], pieceNumber))) {
			std::cout << pieceNumber << std::endl;
			std::cout << piecePosition[pieceNumber] << std::endl;
			piecePosition[pieceNumber] = originalPositionForIllegalReset;
			std::cout << "Illigal move" << std::endl;
		}
	}
	else {
		if (!(checkValidOrKillMovement(piecePosition[pieceNumber], pieceNumber))) {
			piecePosition[pieceNumber] = originalPositionForIllegalReset;
			std::cout << "Illigal move" << std::endl;
		}
	}
	return 0;
}
bool checkValidOrKillMovement(int currentPlayingPiecePosition, int currentPieceNum) { //Checks if a move is legal or not and if it will kill a piece or not
	for (int x = 0; x < (playerCount * 4); x++) {
		if (currentPlayingPiecePosition == piecePosition[x] && currentPieceNum != x) {
			if (currentPlayingPiecePosition == 66 || currentPlayingPiecePosition == 72 || currentPlayingPiecePosition == 78 || currentPlayingPiecePosition == 84) {
				return true;
			}
			else {
				if (x != currentPieceNum) {
					switch (playerColor(currentPieceNum)) {
					case 'r':
						if (playerColor(x) == 'r') {
							return false;
						}
						else if (playerColor(x) == 'b') {
							piecePosition[x] = -2;
							return true;
						}
						else if (playerColor(x) == 'g') {
							piecePosition[x] = -3;
							return true;
						}
						else if (playerColor(x) == 'y') {
							piecePosition[x] = -4;
							return true;
						}
					case 'b':
						if (playerColor(x) == 'r') {
							piecePosition[x] = -1;
							return true;
						}
						else if (playerColor(x) == 'b') {
							return false;
						}
						else if (playerColor(x) == 'g') {
							piecePosition[x] = -3;
							return true;
						}
						else if (playerColor(x) == 'y') {
							piecePosition[x] = -4;
							return true;
						}
					case 'g':
						if (playerColor(x) == 'r') {
							piecePosition[x] = -1;
							return true;
						}
						else if (playerColor(x) == 'b') {
							piecePosition[x] = -2;
							return true;
						}
						else if (playerColor(x) == 'g') {
							return false;
						}
						else if (playerColor(x) == 'y') {
							piecePosition[x] = -4;
							return true;
						}
					case 'y':
						if (playerColor(x) == 'r') {
							piecePosition[x] = -1;
							return true;
						}
						else if (playerColor(x) == 'b') {
							piecePosition[x] = -2;
							return true;
						}
						else if (playerColor(x) == 'g') {
							piecePosition[x] = -3;
							return true;
						}
						else if (playerColor(x) == 'y') {
							return false;
						}
					}
				}
			}
		}
	}
}
void sliderKillCheck(char pieceColor, int sliderPositionCheck) { //Checks if there are any kills on a slider path
	for (int x = 0; x < (playerCount * 4); x++) {
		if (piecePosition[x] == sliderPositionCheck && (pieceColor != playerColor(x))) {
			switch (playerColor(x)) {
			case 'r':
				piecePosition[x] = -1;
				break;
			case 'b':
				piecePosition[x] = -2;
				break;
			case 'g':
				piecePosition[x] = -3;
				break;
			case 'y':
				piecePosition[x] = -4;
				break;
			}
		}
	}
	return;
}
bool sliderCheckAndMove(int currentPlayingPiecePosition, int currentPieceNum) { //Checks if a pice is on the start of a slider and will move them to the end while also checking for kills and legality
	switch (playerColor(currentPieceNum)) {
	case 'r':
		if (currentPlayingPiecePosition == 12 && (!(checkValidOrKillMovement(15, currentPieceNum)))) {
			sliderKillCheck((playerColor(currentPieceNum)), 13);
			sliderKillCheck((playerColor(currentPieceNum)), 14);
			sliderKillCheck((playerColor(currentPieceNum)), 15);
			piecePosition[currentPieceNum] = 15;
			return true;
		}
		else if (currentPlayingPiecePosition == 20 && ((checkValidOrKillMovement(24, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 21);
			sliderKillCheck((playerColor(currentPieceNum)), 22);
			sliderKillCheck((playerColor(currentPieceNum)), 23);
			sliderKillCheck((playerColor(currentPieceNum)), 24);
			piecePosition[currentPieceNum] = 24;
			return true;
		}
		else if (currentPlayingPiecePosition == 27 && ((checkValidOrKillMovement(30, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 28);
			sliderKillCheck((playerColor(currentPieceNum)), 29);
			sliderKillCheck((playerColor(currentPieceNum)), 30);
			piecePosition[currentPieceNum] = 30;
			return true;
		}
		else if (currentPlayingPiecePosition == 35 && ((checkValidOrKillMovement(39, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 36);
			sliderKillCheck((playerColor(currentPieceNum)), 37);
			sliderKillCheck((playerColor(currentPieceNum)), 38);
			sliderKillCheck((playerColor(currentPieceNum)), 39);
			piecePosition[currentPieceNum] = 39;
			return true;
		}
		else if (currentPlayingPiecePosition == 42 && ((checkValidOrKillMovement(45, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 43);
			sliderKillCheck((playerColor(currentPieceNum)), 44);
			sliderKillCheck((playerColor(currentPieceNum)), 45);
			piecePosition[currentPieceNum] = 45;
			return true;
		}
		else if (currentPlayingPiecePosition == 50 && ((checkValidOrKillMovement(54, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 51);
			sliderKillCheck((playerColor(currentPieceNum)), 52);
			sliderKillCheck((playerColor(currentPieceNum)), 53);
			sliderKillCheck((playerColor(currentPieceNum)), 54);
			piecePosition[currentPieceNum] = 54;
			return true;
		}
		else if (currentPlayingPiecePosition == 57) {
			return checkValidOrKillMovement(57, currentPieceNum);
		}
		else if (currentPlayingPiecePosition == 5) {
			return checkValidOrKillMovement(5, currentPieceNum);
		}
		else {
			return false;
		}
	case 'b':
		if (currentPlayingPiecePosition == 57 && ((checkValidOrKillMovement(0, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 58);
			sliderKillCheck((playerColor(currentPieceNum)), 59);
			sliderKillCheck((playerColor(currentPieceNum)), 0);
			piecePosition[currentPieceNum] = 0;
			return true;
		}
		else if (currentPlayingPiecePosition == 5 && ((checkValidOrKillMovement(9, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 6);
			sliderKillCheck((playerColor(currentPieceNum)), 7);
			sliderKillCheck((playerColor(currentPieceNum)), 8);
			sliderKillCheck((playerColor(currentPieceNum)), 9);
			piecePosition[currentPieceNum] = 9;
			return true;
		}
		else if (currentPlayingPiecePosition == 27 && ((checkValidOrKillMovement(30, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 28);
			sliderKillCheck((playerColor(currentPieceNum)), 29);
			sliderKillCheck((playerColor(currentPieceNum)), 30);
			piecePosition[currentPieceNum] = 30;
			return true;
		}
		else if (currentPlayingPiecePosition == 35 && ((checkValidOrKillMovement(39, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 36);
			sliderKillCheck((playerColor(currentPieceNum)), 37);
			sliderKillCheck((playerColor(currentPieceNum)), 38);
			sliderKillCheck((playerColor(currentPieceNum)), 39);
			piecePosition[currentPieceNum] = 39;
			return true;
		}
		else if (currentPlayingPiecePosition == 42 && ((checkValidOrKillMovement(45, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 43);
			sliderKillCheck((playerColor(currentPieceNum)), 44);
			sliderKillCheck((playerColor(currentPieceNum)), 45);
			piecePosition[currentPieceNum] = 45;
			return true;
		}
		else if (currentPlayingPiecePosition == 50 && ((checkValidOrKillMovement(54, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 51);
			sliderKillCheck((playerColor(currentPieceNum)), 52);
			sliderKillCheck((playerColor(currentPieceNum)), 53);
			sliderKillCheck((playerColor(currentPieceNum)), 54);
			piecePosition[currentPieceNum] = 54;
			return true;
		}
		else if (currentPlayingPiecePosition == 12) {
			return checkValidOrKillMovement(12, currentPieceNum);
		}
		else if (currentPlayingPiecePosition == 20) {
			return checkValidOrKillMovement(20, currentPieceNum);
		}
		else {
			return false;
		}
	case 'g':
		if (currentPlayingPiecePosition == 57 && ((checkValidOrKillMovement(0, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 58);
			sliderKillCheck((playerColor(currentPieceNum)), 59);
			sliderKillCheck((playerColor(currentPieceNum)), 0);
			piecePosition[currentPieceNum] = 0;
			return true;
		}
		else if (currentPlayingPiecePosition == 5 && ((checkValidOrKillMovement(9, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 6);
			sliderKillCheck((playerColor(currentPieceNum)), 7);
			sliderKillCheck((playerColor(currentPieceNum)), 8);
			sliderKillCheck((playerColor(currentPieceNum)), 9);
			piecePosition[currentPieceNum] = 9;
			return true;
		}
		else if (currentPlayingPiecePosition == 12 && ((checkValidOrKillMovement(15, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 13);
			sliderKillCheck((playerColor(currentPieceNum)), 14);
			sliderKillCheck((playerColor(currentPieceNum)), 15);
			piecePosition[currentPieceNum] = 15;
			return true;
		}
		else if (currentPlayingPiecePosition == 20 && ((checkValidOrKillMovement(24, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 21);
			sliderKillCheck((playerColor(currentPieceNum)), 22);
			sliderKillCheck((playerColor(currentPieceNum)), 23);
			sliderKillCheck((playerColor(currentPieceNum)), 24);
			piecePosition[currentPieceNum] = 24;
			return true;
		}
		else if (currentPlayingPiecePosition == 42 && ((checkValidOrKillMovement(45, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 43);
			sliderKillCheck((playerColor(currentPieceNum)), 44);
			sliderKillCheck((playerColor(currentPieceNum)), 45);
			piecePosition[currentPieceNum] = 45;
			return true;
		}
		else if (currentPlayingPiecePosition == 50 && ((checkValidOrKillMovement(54, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 51);
			sliderKillCheck((playerColor(currentPieceNum)), 52);
			sliderKillCheck((playerColor(currentPieceNum)), 53);
			sliderKillCheck((playerColor(currentPieceNum)), 54);
			piecePosition[currentPieceNum] = 54;
			return true;
		}
		else if (currentPlayingPiecePosition == 27) {
			return checkValidOrKillMovement(27, currentPieceNum);
		}
		else if (currentPlayingPiecePosition == 35) {
			return checkValidOrKillMovement(35, currentPieceNum);
		}
		else {
			return false;
		}
	case 'y':
		if (currentPlayingPiecePosition == 57 && ((checkValidOrKillMovement(0, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 58);
			sliderKillCheck((playerColor(currentPieceNum)), 59);
			sliderKillCheck((playerColor(currentPieceNum)), 0);
			piecePosition[currentPieceNum] = 0;
			return true;
		}
		else if (currentPlayingPiecePosition == 5 && ((checkValidOrKillMovement(9, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 6);
			sliderKillCheck((playerColor(currentPieceNum)), 7);
			sliderKillCheck((playerColor(currentPieceNum)), 8);
			sliderKillCheck((playerColor(currentPieceNum)), 9);
			piecePosition[currentPieceNum] = 9;
			return true;
		}
		else if (currentPlayingPiecePosition == 12 && ((checkValidOrKillMovement(15, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 13);
			sliderKillCheck((playerColor(currentPieceNum)), 14);
			sliderKillCheck((playerColor(currentPieceNum)), 15);
			piecePosition[currentPieceNum] = 15;
			return true;
		}
		else if (currentPlayingPiecePosition == 20 && ((checkValidOrKillMovement(24, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 21);
			sliderKillCheck((playerColor(currentPieceNum)), 22);
			sliderKillCheck((playerColor(currentPieceNum)), 23);
			sliderKillCheck((playerColor(currentPieceNum)), 24);
			piecePosition[currentPieceNum] = 24;
			return true;
		}
		else if (currentPlayingPiecePosition == 27 && ((checkValidOrKillMovement(30, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 28);
			sliderKillCheck((playerColor(currentPieceNum)), 29);
			sliderKillCheck((playerColor(currentPieceNum)), 30);
			piecePosition[currentPieceNum] = 30;
			return true;
		}
		else if (currentPlayingPiecePosition == 35 && ((checkValidOrKillMovement(39, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 36);
			sliderKillCheck((playerColor(currentPieceNum)), 37);
			sliderKillCheck((playerColor(currentPieceNum)), 38);
			sliderKillCheck((playerColor(currentPieceNum)), 39);
			piecePosition[currentPieceNum] = 39;
			return true;
		}
		else if (currentPlayingPiecePosition == 42) {
			return checkValidOrKillMovement(42, currentPieceNum);
		}
		else if (currentPlayingPiecePosition == 50) {
			return checkValidOrKillMovement(50, currentPieceNum);
		}
		else {
			return false;
		}
	}
}
int cardDraw() {
	int cardNumber;
	bool availableCard = false;
	if (one == 0 && two == 0 && three == 0 && four == 0 && five == 0 && six == 0 && seven == 0 && eight == 0 && nine == 0 && ten == 0 && eleven == 0 && twelve == 0 && sorry == 0) {
		one = (5);
		two = (4);
		three = (4);
		four = (4);
		five = (4);
		six = (4);
		seven = (4);
		eight = (4);
		nine = (4);
		ten = (4);
		eleven = (4);
		twelve = (4);
		sorry = (4);
	}
	do {
		std::mt19937 rng;
		rng.seed(std::random_device()());
		std::uniform_int_distribution<std::mt19937::result_type> random(1, 13); // distribution in range [1, 6] 
		cardNumber = random(rng);
		switch (cardNumber) {
		case 1:
			if (one >= 1) {
				one--;
				availableCard = true;
			}
			break;
		case 2:
			if (two >= 1) {
				two--;
				availableCard = true;
			}
			break;
		case 3:
			if (three >= 1) {
				three--;
				availableCard = true;
			}
			break;
		case 4:
			if (four >= 1) {
				four--;
				availableCard = true;
			}
			break;
		case 5:
			if (five >= 1) {
				five--;
				availableCard = true;
			}
			break;
		case 6:
			if (six >= 1) {
				six--;
				availableCard = true;
			}
			break;
		case 7:
			if (seven >= 1) {
				seven--;
				availableCard = true;
			}
			break;
		case 8:
			if (eight >= 1) {
				eight--;
				availableCard = true;
			}
			break;
		case 9:
			if (nine >= 1) {
				nine--;
				availableCard = true;
			}
			break;
		case 10:
			if (ten >= 1) {
				ten--;
				availableCard = true;
			}
			break;
		case 11:
			if (eleven >= 1) {
				eleven--;
				availableCard = true;
			}
			break;
		case 12:
			if (twelve >= 1) {
				twelve--;
				availableCard = true;
			}
			break;
		case 13:
			if (sorry >= 1) {
				sorry--;
				availableCard = true;
			}
			break;
		}
	} while (availableCard == false);
	return cardNumber;
}
char playerColorTurn(int cardNumber) {
	static int turn;
	if (playerCount == 4) {
		turn++;
		if (turn > 4) {
			turn = 1;
		}
	}
	else if (playerCount == 3) {
		turn++;
		if (turn > 3) {
			turn = 1;
		}
	}
	else if (playerCount == 2) {
		turn++;
		if (turn > 2) {
			turn = 1;
		}
	}

	switch (turn) {
	case 1:
		if (cardNumber == 2) {
			turn--;
		}
		return 'r';
		break;
	case 2:
		if (cardNumber == 2) {
			turn--;
		}
		return 'b';
		break;
	case 3:
		if (cardNumber == 2) {
			turn--;
		}
		return 'g';
		break;
	case 4:
		if (cardNumber == 2) {
			turn--;
		}
		return 'y';
		break;
	}
}
int playerMovementInput(char colorOfPlayer) {
	std::cout << "Input what piece you would like to move." << std::endl;
	bool intCheck = false;
	int input = 0;
	do {
		std::cout << "Make sure it's either 1, 2, 3 or 4!\n";
		std::cin >> input;
		if ((input == 1 || input == 2 || input == 3 || input == 4)) {
			intCheck = true;
		}
		std::cin.clear();
		std::cin.ignore();
	} while (!(intCheck));
	switch (input) {
	case 1:
		if (colorOfPlayer == 'r') {
			return 0;
		}
		else if (colorOfPlayer == 'b') {
			return 4;
		}
		else if (colorOfPlayer == 'g') {
			return 8;
		}
		else if (colorOfPlayer == 'y') {
			return 12;
		}
	case 2:
		if (colorOfPlayer == 'r') {
			return 1;
		}
		else if (colorOfPlayer == 'b') {
			return 5;
		}
		else if (colorOfPlayer == 'g') {
			return 9;
		}
		else if (colorOfPlayer == 'y') {
			return 13;
		}
	case 3:
		if (colorOfPlayer == 'r') {
			return 2;
		}
		else if (colorOfPlayer == 'b') {
			return 6;
		}
		else if (colorOfPlayer == 'g') {
			return 10;
		}
		else if (colorOfPlayer == 'y') {
			return 14;
		}
	case 4:
		if (colorOfPlayer == 'r') {
			return 3;
		}
		else if (colorOfPlayer == 'b') {
			return 7;
		}
		else if (colorOfPlayer == 'g') {
			return 11;
		}
		else if (colorOfPlayer == 'y') {
			return 15;
		}
	}
}
bool checkIfPlayerWon(char colorOfPlayer) {
	switch (colorOfPlayer) {
	case 'r':
		if (piecePosition[0] == 66 && piecePosition[1] == 66 && piecePosition[2] == 66 && piecePosition[3] == 66) {
			return true;
		}
		else {
			return false;
		}
	case 'b':
		if (piecePosition[4] == 72 && piecePosition[5] == 72 && piecePosition[6] == 72 && piecePosition[7] == 72) {
			return true;
		}
		else {
			return false;
		}
	case 'g':
		if (piecePosition[8] == 78 && piecePosition[9] == 78 && piecePosition[10] == 78 && piecePosition[11] == 78) {
			return true;
		}
		else {
			return false;
		}
	case 'y':
		if (piecePosition[12] == 84 && piecePosition[13] == 84 && piecePosition[14] == 84 && piecePosition[15] == 84) {
			return true;
		}
		else {
			return false;
		}
	}
}
void sorryCardActivation(char currentPlayerColor, int currentPieceNumber) { //Function for sorry card
	bool pieceInStart = false;
	bool pieceOnBoard = false;
	for (int x = 0; x < playerCount * 4; x++) {
		if (currentPlayerColor == playerColor(x)) {
			switch (currentPlayerColor) {
			case 'r':
				if (piecePosition[x] == -1) {
					pieceInStart = true;
				} break;
			case 'b':
				if (piecePosition[x] == -2) {
					pieceInStart = true;
				} break;
			case 'g':
				if (piecePosition[x] == -3) {
					pieceInStart = true;
				} break;
			case 'y':
				if (piecePosition[x] == -4) {
					pieceInStart = true;
				} break;
			}
		}
		if (currentPlayerColor != playerColor(x)) {
			switch (currentPlayerColor) {
			case 'r':
				if (piecePosition[x] >= 0 && piecePosition[x] <= 59) {
					pieceOnBoard = true;
				} break;
			case 'b':
				if (piecePosition[x] >= 0 && piecePosition[x] <= 59) {
					pieceOnBoard = true;
				} break;
			case 'g':
				if (piecePosition[x] >= 0 && piecePosition[x] <= 59) {
					pieceOnBoard = true;
				} break;
			case 'y':
				if (piecePosition[x] >= 0 && piecePosition[x] <= 59) {
					pieceOnBoard = true;
				} break;
			}
		}
	}
	if (pieceOnBoard == true && pieceInStart == true) {
		int currentClosestDistance = 999;
		int currentClosestPieceNum;
		for (int j = 0; j < playerCount * 4; j++) {
			if (currentPlayerColor != playerColor(j)) {
				if (piecePosition[j] >= 0 && piecePosition[j] <= 59) {
					int positionToTest;
					switch (currentPlayerColor) {
					case 'r':
						positionToTest = 59 - piecePosition[j];
						if (positionToTest >= 0) {
							if (positionToTest < currentClosestDistance) {
								currentClosestDistance = positionToTest;
								currentClosestPieceNum = j;
							}
						}
						if (positionToTest < 0 && currentClosestDistance < 0) {
							if (positionToTest < currentClosestDistance) {
								currentClosestDistance = positionToTest;
								currentClosestPieceNum = j;
							}
						}
						break;
					case 'b':
						positionToTest = 14 - piecePosition[j];
						if (positionToTest >= 0) {
							if (positionToTest < currentClosestDistance) {
								currentClosestDistance = positionToTest;
								currentClosestPieceNum = j;
							}
						}
						if (positionToTest < 0 && currentClosestDistance < 0) {
							if (positionToTest < currentClosestDistance) {
								currentClosestDistance = positionToTest;
								currentClosestPieceNum = j;
							}
						}
						break;
					case 'g':
						positionToTest = 29 - piecePosition[j];
						if (positionToTest >= 0) {
							if (positionToTest < currentClosestDistance) {
								currentClosestDistance = positionToTest;
								currentClosestPieceNum = j;
							}
						}
						if (positionToTest < 0 && currentClosestDistance < 0) {
							if (positionToTest < currentClosestDistance) {
								currentClosestDistance = positionToTest;
								currentClosestPieceNum = j;
							}
						}
						break;
					case 'y':
						positionToTest = 44 - piecePosition[j];
						if (positionToTest >= 0) {
							if (positionToTest < currentClosestDistance) {
								currentClosestDistance = positionToTest;
								currentClosestPieceNum = j;
							}
						}
						if (positionToTest < 0 && currentClosestDistance < 0) {
							if (positionToTest < currentClosestDistance) {
								currentClosestDistance = positionToTest;
								currentClosestPieceNum = j;
							}
						}
					}
				}
			}
		}
		piecePosition[currentPieceNumber] = piecePosition[currentClosestPieceNum];
		switch (playerColor(currentClosestPieceNum)) {
		case 'r':
			piecePosition[currentClosestPieceNum] = -1;
			break;
		case 'b':
			piecePosition[currentClosestPieceNum] = -2;
			break;
		case 'g':
			piecePosition[currentClosestPieceNum] = -3;
			break;
		case 'y':
			piecePosition[currentClosestPieceNum] = -4;
			break;
		}
	}
}
void swapPosition(char playerColorCheck) {
	bool intCheck = false;
	bool intCheck2 = false;
	int input = 0;
	int input2 = 0;
	do {
		std::cout << "What two would you like to swap? \nType any number (Your piece) from 1 to 16:\n1-Red 1, 2-Red 2, 3-Red 3, 4-Red 4                         5-Blue 1, 6-Blue 2, 7-Blue 3, 8-Blue 4\n";
		std::cout << "9-Green 1, 10-Green 2, 11-Green 3, 12-Green 4              13-Yellow 1, 14-Yellow 2, 15-Yellow 3, 16-Yellow 4\n";
		std::cin >> input;
		if ((input == 1 || input == 2 || input == 3 || input == 4 || input == 5 || input == 6 || input == 7 || input == 8 || input == 9 || input == 10 || input == 11 || input == 12 || input == 13 || input == 14 || input == 15 || input == 16)) {
			intCheck = true;
		}
		std::cin.clear();
		std::cin.ignore();
	} while (!(intCheck));
	do {
		std::cout << "What two would you like to swap? \nType any number (Any piece you wish to swap with) from 1 to 16:\n 1 - Red 1, 2 - Red 2, 3 - Red 3, 4 - Red 4                5-Blue 1, 6 - Blue 2, 7 - Blue 3, 8 - Blue 4\n";
		std::cout << "9-Green 1, 10-Green 2, 11-Green 3, 12-Green 4              13-Yellow 1, 14-Yellow 2, 15-Yellow 3, 16-Yellow 4\n";
		std::cin >> input2;
		if ((input2 == 1 || input2 == 2 || input2 == 3 || input2 == 4 || input2 == 5 || input2 == 6 || input2 == 7 || input2 == 8 || input2 == 9 || input2 == 10 || input2 == 11 || input2 == 12 || input2 == 13 || input2 == 14 || input2 == 15 || input2 == 16)) {
			intCheck2 = true;
		}
		std::cin.clear();
		std::cin.ignore();
	} while (!(intCheck2));
	input--;
	input2--;
	if (piecePosition[input] == -1 || piecePosition[input] == -2 || piecePosition[input] == -3 || piecePosition[input] == -4 || piecePosition[input2] == -1 || piecePosition[input2] == -2 || piecePosition[input2] == -3 || piecePosition[input2] == -4 || piecePosition[input2] > 59 || piecePosition[input] > 59) {
		std::cout << "Invalid Swap Detected!\n";
		return;
	}
	if (playerColor(input) != playerColorCheck) {
		std::cout << "Invalid Swap Detected!\n";
		return;
	}
	int tempNumStoring;
	tempNumStoring = piecePosition[input];
	piecePosition[input] = piecePosition[input2];
	piecePosition[input2] = tempNumStoring;
	return;
}
bool userSwapOrMove(char playerColorCheck) {
	bool intCheck = false;
	int input = 0;
	do {
		std::cout << "Would you like to swap? Type 1 for yes or 2 for no.\n";// 1, 2, 3 or 4!\n";
		std::cin >> input;
		if ((input == 1 || input == 2)) {
			intCheck = true;
		}
		std::cin.clear();
		std::cin.ignore();
	} while (!(intCheck));
	switch (input) {
	case 1:
		swapPosition(playerColorCheck);
		return true;
	case 2:
		return false;
	}
}
void displayBoard() {
	std::string gameBoard =
		" _______________________________________________________________________________\n"
		"|    |>   |>   |>   |>   |    |    |    |    |>   |>   |>   |>   |>   |    |    |\n"
		" _____________________^_________________________________________________________\n"
		"|    |	  |    |                                                           |V   |\n"
		" ____	   ____       Start                   ~~~~ ____ ____ ____ ____ ____ ____\n"
		"|   ^|	  |    |                             {    }    |    |    |    |    |V   |\n"
		" ____	   ____                               ~~~~ ____ ____ ____ ____ ____ ____\n"
		"|   ^|	  |    |                                                           |V   |\n"
		" ____	   ____                                                             ____\n"
		"|   ^|	  |    |                                                           >V   |\n"
		" ____	   ____                                                      Start  ____\n"
		"|   ^|	  |    |                                                           |    |\n"
		" ____	   ~~~~                                                             ____\n"
		"|   ^|	  {    }                                                           |    |\n"
		" ____	   ~~~~                                                             ____\n"
		"|    |                                                                     |    |\n"
		" ____                                                                       ____\n"
		"|    |                                                                     |    |\n"
		" ____                                                             ~~~~      ____\n"
		"|    |                                                           {    }    |V   |\n"
		" ____                                                             ~~~~      ____\n"
		"|    |   Start                                                   |    |    |V   |\n"
		" ____                                                             ____      ____\n"
		"|   ^<                                                           |    |    |V   |\n"
		" ____                                                             ____      ____\n"
		"|   ^|                                                           |    |    |V   |\n"
		" ____ ____ ____ ____ ____ ____ ~~~~                               ____      ____\n"
		"|   ^|    |    |    |    |    {    }                             |    |    |V   |\n"
		" ____ ____ ____ ____ ____ ____ ~~~~                    Start      ____      ____\n"
		"|   ^|                                                           |    |    |    |\n"
		" ________________________________________________________V______________________\n"
		"|    |    |   <|   <|   <|   <|   <|    |    |    |    |   <|   <|   <|   <|    |\n"
		" _______________________________________________________________________________\n";
	int y = 0;

	for (int x = 0; x < (sizeof(piecePosition) / sizeof(*piecePosition)); x++) {
		std::string numToInsert;
		std::string charToInsert;
		if (y == 4) {
			y = 0;
		}
		y++;
		if (y == 1) {
			numToInsert = "1";
		}
		if (y == 2) {
			numToInsert = "2";
		}
		if (y == 3) {
			numToInsert = "3";
		}
		if (y == 4) {
			numToInsert = "4";
		}
		if (playerColor(x) == 'r') {
			charToInsert = "R";
		}
		if (playerColor(x) == 'b') {
			charToInsert = "B";
		}
		if (playerColor(x) == 'g') {
			charToInsert = "G";
		}
		if (playerColor(x) == 'y') {
			charToInsert = "Y";
		}
		switch (piecePosition[x]) {
		case 1:
			gameBoard.replace(104, 1, numToInsert);
			gameBoard.replace(105, 1, charToInsert);
			break;
		case 2:
			gameBoard.replace(109, 1, numToInsert);
			gameBoard.replace(110, 1, charToInsert);
			break;
		case 3:
			gameBoard.replace(114, 1, numToInsert);
			gameBoard.replace(115, 1, charToInsert);
			break;
		case 4:
			gameBoard.replace(119, 1, numToInsert);
			gameBoard.replace(120, 1, charToInsert);
			break;
		case 5:
			gameBoard.replace(124, 1, numToInsert);
			gameBoard.replace(125, 1, charToInsert);
			break;
		case 6:
			gameBoard.replace(129, 1, numToInsert);
			gameBoard.replace(130, 1, charToInsert);
		case 7:
			gameBoard.replace(134, 1, numToInsert);
			gameBoard.replace(135, 1, charToInsert);
			break;
		case 8:
			gameBoard.replace(139, 1, numToInsert);
			gameBoard.replace(140, 1, charToInsert);
			break;
		case 9:
			gameBoard.replace(144, 1, numToInsert);
			gameBoard.replace(145, 1, charToInsert);
			break;
		case 10:
			gameBoard.replace(149, 1, numToInsert);
			gameBoard.replace(150, 1, charToInsert);
			break;
		case 11:
			gameBoard.replace(154, 1, numToInsert);
			gameBoard.replace(155, 1, charToInsert);
			break;
		case 12:
			gameBoard.replace(159, 1, numToInsert);
			gameBoard.replace(160, 1, charToInsert);
			break;
		case 13:
			gameBoard.replace(321, 1, numToInsert);
			gameBoard.replace(322, 1, charToInsert);
			break;
		case 14:
			gameBoard.replace(481, 1, numToInsert);
			gameBoard.replace(482, 1, charToInsert);
			break;
		case 15:
			gameBoard.replace(641, 1, numToInsert);
			gameBoard.replace(642, 1, charToInsert);
			break;
		case 16:
			gameBoard.replace(801, 1, numToInsert);
			gameBoard.replace(802, 1, charToInsert);
			break;
		case 17:
			gameBoard.replace(961, 1, numToInsert);
			gameBoard.replace(962, 1, charToInsert);
			break;
		case 18:
			gameBoard.replace(1121, 1, numToInsert);
			gameBoard.replace(1122, 1, charToInsert);
			break;
		case 19:
			gameBoard.replace(1282, 1, numToInsert);
			gameBoard.replace(1283, 1, charToInsert);
			break;
		case 20:
			gameBoard.replace(1445, 1, numToInsert);
			gameBoard.replace(1446, 1, charToInsert);
			break;
		case 21:
			gameBoard.replace(1608, 1, numToInsert);
			gameBoard.replace(1609, 1, charToInsert);
			break;
		case 22:
			gameBoard.replace(1771, 1, numToInsert);
			gameBoard.replace(1772, 1, charToInsert);
			break;
		case 23:
			gameBoard.replace(1934, 1, numToInsert);
			gameBoard.replace(1935, 1, charToInsert);
			break;
		case 24:
			gameBoard.replace(2097, 1, numToInsert);
			gameBoard.replace(2098, 1, charToInsert);
			break;
		case 25:
			gameBoard.replace(2260, 1, numToInsert);
			gameBoard.replace(2261, 1, charToInsert);
			break;
		case 26:
			gameBoard.replace(2423, 1, numToInsert);
			gameBoard.replace(2424, 1, charToInsert);
			break;
		case 27:
			gameBoard.replace(2586, 1, numToInsert);
			gameBoard.replace(2587, 1, charToInsert);
			break;
		case 28:
			gameBoard.replace(2579, 1, numToInsert);
			gameBoard.replace(2580, 1, charToInsert);
			break;
		case 29:
			gameBoard.replace(2574, 1, numToInsert);
			gameBoard.replace(2575, 1, charToInsert);
			break;
		case 30:
			gameBoard.replace(2569, 1, numToInsert);
			gameBoard.replace(2570, 1, charToInsert);
			break;
		case 31:
			gameBoard.replace(2564, 1, numToInsert);
			gameBoard.replace(2565, 1, charToInsert);
			break;
		case 32:
			gameBoard.replace(2559, 1, numToInsert);
			gameBoard.replace(2560, 1, charToInsert);
			break;
		case 33:
			gameBoard.replace(2554, 1, numToInsert);
			gameBoard.replace(2555, 1, charToInsert);
			break;
		case 34:
			gameBoard.replace(2549, 1, numToInsert);
			gameBoard.replace(2550, 1, charToInsert);
			break;
		case 35:
			gameBoard.replace(2544, 1, numToInsert);
			gameBoard.replace(2545, 1, charToInsert);
			break;
		case 36:
			gameBoard.replace(2539, 1, numToInsert);
			gameBoard.replace(2540, 1, charToInsert);
			break;
		case 37:
			gameBoard.replace(2534, 1, numToInsert);
			gameBoard.replace(2535, 1, charToInsert);
			break;
		case 38:
			gameBoard.replace(2529, 1, numToInsert);
			gameBoard.replace(2530, 1, charToInsert);
			break;
		case 39:
			gameBoard.replace(2524, 1, numToInsert);
			gameBoard.replace(2525, 1, charToInsert);
			break;
		case 40:
			gameBoard.replace(2519, 1, numToInsert);
			gameBoard.replace(2520, 1, charToInsert);
			break;
		case 41:
			gameBoard.replace(2514, 1, numToInsert);
			gameBoard.replace(2515, 1, charToInsert);
			break;
		case 42:
			gameBoard.replace(2509, 1, numToInsert);
			gameBoard.replace(2510, 1, charToInsert);
			break;
		case 43:
			gameBoard.replace(2346, 1, numToInsert);
			gameBoard.replace(2347, 1, charToInsert);
			break;
		case 44:
			gameBoard.replace(2183, 1, numToInsert);
			gameBoard.replace(2184, 1, charToInsert);
			break;
		case 45:
			gameBoard.replace(2020, 1, numToInsert);
			gameBoard.replace(2021, 1, charToInsert);
			break;
		case 46:
			gameBoard.replace(1857, 1, numToInsert);
			gameBoard.replace(1858, 1, charToInsert);
			break;
		case 47:
			gameBoard.replace(1694, 1, numToInsert);
			gameBoard.replace(1695, 1, charToInsert);
			break;
		case 48:
			gameBoard.replace(1531, 1, numToInsert);
			gameBoard.replace(1532, 1, charToInsert);
			break;
		case 49:
			gameBoard.replace(1368, 1, numToInsert);
			gameBoard.replace(1369, 1, charToInsert);
			break;
		case 50:
			gameBoard.replace(1205, 1, numToInsert);
			gameBoard.replace(1206, 1, charToInsert);
			break;
		case 51:
			gameBoard.replace(1045, 1, numToInsert);
			gameBoard.replace(1046, 1, charToInsert);
			break;
		case 52:
			gameBoard.replace(885, 1, numToInsert);
			gameBoard.replace(886, 1, charToInsert);
			break;
		case 53:
			gameBoard.replace(725, 1, numToInsert);
			gameBoard.replace(726, 1, charToInsert);
			break;
		case 54:
			gameBoard.replace(565, 1, numToInsert);
			gameBoard.replace(566, 1, charToInsert);
			break;
		case 55:
			gameBoard.replace(405, 1, numToInsert);
			gameBoard.replace(406, 1, charToInsert);
			break;
		case 56:
			gameBoard.replace(245, 1, numToInsert);
			gameBoard.replace(246, 1, charToInsert);
			break;
		case 57:
			gameBoard.replace(82, 1, numToInsert);
			gameBoard.replace(83, 1, charToInsert);
			break;
		case 58:
			gameBoard.replace(89, 1, numToInsert);
			gameBoard.replace(90, 1, charToInsert);
			break;
		case 59:
			gameBoard.replace(94, 1, numToInsert);
			gameBoard.replace(95, 1, charToInsert);
			break;
		case 0:
			gameBoard.replace(99, 1, numToInsert);
			gameBoard.replace(100, 1, charToInsert);
			break;
		case 61:
			gameBoard.replace(255, 1, numToInsert);
			gameBoard.replace(256, 1, charToInsert);
			break;
		case 62:
			gameBoard.replace(415, 1, numToInsert);
			gameBoard.replace(416, 1, charToInsert);
			break;
		case 63:
			gameBoard.replace(575, 1, numToInsert);
			gameBoard.replace(576, 1, charToInsert);
			break;
		case 64:
			gameBoard.replace(735, 1, numToInsert);
			gameBoard.replace(736, 1, charToInsert);
			break;
		case 65:
			gameBoard.replace(895, 1, numToInsert);
			gameBoard.replace(896, 1, charToInsert);
			break;
		case 66:
			gameBoard.replace(1055, 1, numToInsert);
			gameBoard.replace(1056, 1, charToInsert);
			break;
		case 67:
			gameBoard.replace(475, 1, numToInsert);
			gameBoard.replace(476, 1, charToInsert);
			break;
		case 68:
			gameBoard.replace(470, 1, numToInsert);
			gameBoard.replace(471, 1, charToInsert);
			break;
		case 69:
			gameBoard.replace(465, 1, numToInsert);
			gameBoard.replace(466, 1, charToInsert);
			break;
		case 70:
			gameBoard.replace(460, 1, numToInsert);
			gameBoard.replace(461, 1, charToInsert);
			break;
		case 71:
			gameBoard.replace(455, 1, numToInsert);
			gameBoard.replace(456, 1, charToInsert);
			break;
		case 72:
			gameBoard.replace(450, 1, numToInsert);
			gameBoard.replace(451, 1, charToInsert);
			break;
		case 73:
			gameBoard.replace(1597, 1, numToInsert);
			gameBoard.replace(1598, 1, charToInsert);
			break;
		case 74:
			gameBoard.replace(1760, 1, numToInsert);
			gameBoard.replace(1761, 1, charToInsert);
			break;
		case 75:
			gameBoard.replace(1923, 1, numToInsert);
			gameBoard.replace(1924, 1, charToInsert);
			break;
		case 76:
			gameBoard.replace(2086, 1, numToInsert);
			gameBoard.replace(2087, 1, charToInsert);
			break;
		case 77:
			gameBoard.replace(2249, 1, numToInsert);
			gameBoard.replace(2250, 1, charToInsert);
			break;
		case 78:
			gameBoard.replace(2412, 1, numToInsert);
			gameBoard.replace(2413, 1, charToInsert);
			break;
		case 79:
			gameBoard.replace(2189, 1, numToInsert);
			gameBoard.replace(2190, 1, charToInsert);
			break;
		case 80:
			gameBoard.replace(2194, 1, numToInsert);
			gameBoard.replace(2195, 1, charToInsert);
			break;
		case 81:
			gameBoard.replace(2199, 1, numToInsert);
			gameBoard.replace(2200, 1, charToInsert);
			break;
		case 82:
			gameBoard.replace(2204, 1, numToInsert);
			gameBoard.replace(2205, 1, charToInsert);
			break;
		case 83:
			gameBoard.replace(2209, 1, numToInsert);
			gameBoard.replace(2210, 1, charToInsert);
			break;
		case 84:
			gameBoard.replace(2214, 1, numToInsert);
			gameBoard.replace(2215, 1, charToInsert);
			break;
		case -1:
			gameBoard.replace(266, 1, numToInsert);
			gameBoard.replace(267, 1, charToInsert);
			break;
		case -2:
			gameBoard.replace(795, 1, numToInsert);
			gameBoard.replace(796, 1, charToInsert);
			break;
		case -4:
			gameBoard.replace(1863, 1, numToInsert);
			gameBoard.replace(1864, 1, charToInsert);
			break;
		case -3:
			gameBoard.replace(2402, 1, numToInsert);
			gameBoard.replace(2403, 1, charToInsert);
			break;
		}

	}

	std::cout << gameBoard;
}
char gamePlayingFunction() {
	std::cout << "How many players?\n";
	std::cin >> playerCount;
	playerDataGenerator(playerCount);
	boardGenerator();
	char currentPlayingColor;
	do {
		displayBoard();
		//Draws the card
		//Takes input from user to allow the movement and decision of what piece to move
		int cardDrawn = cardDraw();
		bool didSwitch = false;
		currentPlayingColor = playerColorTurn(cardDrawn);
		std::cout << "\nYou drew: " << cardDrawn << std::endl;
		std::string color;
		switch (currentPlayingColor) {
		case 'r':
			color = "Red";
			break;
		case 'b':
			color = "Blue";
			break;
		case 'g':
			color = "Green";
			break;
		case 'y':
			color = "Yellow";
			break;
		}
		std::cout << "Current Plaring Color is:  " << color << std::endl << std::endl;
		
		if (cardDrawn == 11) {
			didSwitch = userSwapOrMove(currentPlayingColor);
		}
		if (didSwitch == false) {
			playerMovement(playerMovementInput(currentPlayingColor), cardDrawn); //Will move pieces and checks for the kills and sliders
		}
		system("pause");
		std::cout << std::endl;
		system("CLS"); //Clears screen
		//This for loop is simply here to test the game and see if it is running or not
		//Will be deleted later
		
	} while (checkIfPlayerWon(currentPlayingColor) == false);
	return currentPlayingColor;
}

int main() { //main function
	//title screen could go here
	std::cout << "SORRY!" << std::endl;


	switch (gamePlayingFunction()) {
	case 'r':
		std::cout << "Red is the winner!" << std::endl;
		break;
	case 'b':
		std::cout << "Blue is the winner!" << std::endl;
		break;
	case 'g':
		std::cout << "Green is the winner!" << std::endl;
		break;
	case 'y':
		std::cout << "Yellow is the winner!" << std::endl;
		break;
	}
	system("pause");
	return 0;
}