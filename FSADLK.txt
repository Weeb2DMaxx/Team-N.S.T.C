#include <iostream>
#include <random>
#include <string>

int playerNumGenerator(int);
int playerDataGenerator(int);
char playerColor(int);
int boardGenerator();
int main();
int playerMovement(int, int);
bool checkValidOrKillMovement(int, int);
void sliderKillCheck(char, int);
bool sliderCheckAndMove(int, int);
int cardDraw();
char playerColorTurn(int);
int playerMovementInput(char);
bool checkIfPlayerWon(char);
void sorryCardActivation(char, int);
void swapPosition(char);
bool userSwapOrMove(char);
void displayBoard();
char gamePlayingFunction();

int playerCount = 2;
char teamColor[] = { 'r', 'b', 'g', 'y' };
int pieceIdentifier[16] = { 999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999 };
int piecePosition[16] = { 999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999 };
int sliders[] = { 57, 0, 5, 9,     12, 15, 20, 24,         27, 30, 35, 39,           42, 45, 50, 54 };
int gameBoard[84] = {};
int one(5), two(4), three(4), four(4), five(4), six(4), seven(4), eight(4), nine(4), ten(4), eleven(4), twelve(4), sorry(4); //cardAmounts


int playerNumGenerator(int a) { //generates a number of each piece based off the numbers of players
	static int pieceNumber = 0;
	pieceIdentifier[a] = pieceNumber;
	pieceNumber++;
	return 0;
}
char playerColor(int pieceNum) { //function used to determine the color of a piece
	return teamColor[pieceNum / 4];
}
int playerDataGenerator(int playerCount) { //Function that will load all data necessary for the game
	for (int a = 0; a < (playerCount * 4); a++) { //Generates the player pieces and assigns them to their base
		playerNumGenerator(a);
		switch (playerColor(a)) {
		case 'r':
			piecePosition[a] = -1;
			break;
		case 'b':
			piecePosition[a] = -2;
			break;
		case 'g':
			piecePosition[a] = -3;
			break;
		case 'y':
			piecePosition[a] = -4;
			break;
		}
	}


	return 0;
}
int boardGenerator() { //Generates a board (I think this may be useless honestly)
	int b = 0;
	do {
		static int a = 0;
		gameBoard[a] = a;
		a++;
		b++;
	} while (b < 84);
	return 0;
}
int playerMovement(int pieceNumber, int movementLeft) { //This function will move the pieces and check validity with other functions (the movement function)
	int originalPositionForIllegalReset = piecePosition[pieceNumber];
	if (piecePosition[pieceNumber] == 66 || piecePosition[pieceNumber] == 72 || piecePosition[pieceNumber] == 78 || piecePosition[pieceNumber] == 84) {
		movementLeft = 0;
	}
	if (movementLeft == 13) {
		movementLeft = 0;
		sorryCardActivation(playerColor(pieceNumber), pieceNumber);
	}
	if (movementLeft == 4) {
		movementLeft = -4;
	}

	if (piecePosition[pieceNumber] == -1 || piecePosition[pieceNumber] == -2 || piecePosition[pieceNumber] == -3 || piecePosition[pieceNumber] == -4) {
		if (movementLeft == 1 || movementLeft == 2) {
			movementLeft = 0;
			switch (playerColor(pieceNumber)) {
			case 'r':
				if (checkValidOrKillMovement(1, pieceNumber)) {
					piecePosition[pieceNumber] = 1;
				}
				break;
			case 'b':
				if (checkValidOrKillMovement(16, pieceNumber)) {
					piecePosition[pieceNumber] = 16;
				}
				break;
			case 'g':
				if (checkValidOrKillMovement(31, pieceNumber)) {
					piecePosition[pieceNumber] = 31;
				}
				break;
			case 'y':
				if (checkValidOrKillMovement(46, pieceNumber)) {
					piecePosition[pieceNumber] = 46;
				}
				break;
			}
		}
		else {
			movementLeft = 0;
		}
	}
	if (movementLeft > 0) {
		for (int x = 0; x < movementLeft; x++) {
			piecePosition[pieceNumber] += 1;
			switch (playerColor(pieceNumber)) {
			case 'r':
				if (piecePosition[pieceNumber] == 59 && playerColor(pieceNumber) == 'r') {
					piecePosition[pieceNumber] = 61;
				}
				break;
			case 'b':
				if (piecePosition[pieceNumber] == 14 && playerColor(pieceNumber) == 'b') {
					piecePosition[pieceNumber] = 67;
				}
				break;
			case 'g':
				if (piecePosition[pieceNumber] == 29 && playerColor(pieceNumber) == 'g') {
					piecePosition[pieceNumber] = 73;
				}
				break;
			case 'y':
				if (piecePosition[pieceNumber] == 44 && playerColor(pieceNumber) == 'y') {
					piecePosition[pieceNumber] = 79;
				}
				break;
			}
			if (piecePosition[pieceNumber] == 59) {
				piecePosition[pieceNumber] = 0;
			}
			if (piecePosition[pieceNumber] == 66 || piecePosition[pieceNumber] == 72 || piecePosition[pieceNumber] == 78 || piecePosition[pieceNumber] == 84) {
				movementLeft = 0;
			}
		}
	}
	else if (movementLeft < 0) {
		for (int x = 0; x > movementLeft; x--) {
			piecePosition[pieceNumber] -= 1;
			switch (playerColor(pieceNumber)) {
			case 'r':
				if (piecePosition[pieceNumber] == 60) {
					piecePosition[pieceNumber] = 58;
				}
			case 'b':
				if (piecePosition[pieceNumber] == 66) {
					piecePosition[pieceNumber] = 13;
				}
			case 'g':
				if (piecePosition[pieceNumber] == 29) {
					piecePosition[pieceNumber] = 28;
				}
			case 'y':
				if (piecePosition[pieceNumber] == 78) {
					piecePosition[pieceNumber] = 43;
				}
			}
			if (piecePosition[pieceNumber] == -1) {
				piecePosition[pieceNumber] = 59;
			}
		}
	}
	if (piecePosition[pieceNumber] == 58 || piecePosition[pieceNumber] == 6 || piecePosition[pieceNumber] == 13 || piecePosition[pieceNumber] == 21 || piecePosition[pieceNumber] == 28 || piecePosition[pieceNumber] == 36 || piecePosition[pieceNumber] == 43 || piecePosition[pieceNumber] == 51) {
		if (!(sliderCheckAndMove(piecePosition[pieceNumber], pieceNumber))) {
			std::cout << pieceNumber << std::endl;
			std::cout << piecePosition[pieceNumber] << std::endl;
			piecePosition[pieceNumber] = originalPositionForIllegalReset;
			std::cout << "Illegal move" << std::endl;
		}
	}
	else {
		if (!(checkValidOrKillMovement(piecePosition[pieceNumber], pieceNumber))) {
			piecePosition[pieceNumber] = originalPositionForIllegalReset;
			std::cout << "Illegal move" << std::endl;
		}
	}
	return 0;
}
bool checkValidOrKillMovement(int currentPlayingPiecePosition, int currentPieceNum) { //Checks if a move is legal or not and if it will kill a piece or not
	for (int x = 0; x < (playerCount * 4); x++) {
		if (currentPlayingPiecePosition == piecePosition[x] && currentPieceNum != x) {
			if (currentPlayingPiecePosition == 66 || currentPlayingPiecePosition == 72 || currentPlayingPiecePosition == 78 || currentPlayingPiecePosition == 84) {
				return true;
			}
			else {
				if (x != currentPieceNum) {
					switch (playerColor(currentPieceNum)) {
					case 'r':
						if (playerColor(x) == 'r') {
							return false;
						}
						else if (playerColor(x) == 'b') {
							piecePosition[x] = -2;
							return true;
						}
						else if (playerColor(x) == 'g') {
							piecePosition[x] = -3;
							return true;
						}
						else if (playerColor(x) == 'y') {
							piecePosition[x] = -4;
							return true;
						}
					case 'b':
						if (playerColor(x) == 'r') {
							piecePosition[x] = -1;
							return true;
						}
						else if (playerColor(x) == 'b') {
							return false;
						}
						else if (playerColor(x) == 'g') {
							piecePosition[x] = -3;
							return true;
						}
						else if (playerColor(x) == 'y') {
							piecePosition[x] = -4;
							return true;
						}
					case 'g':
						if (playerColor(x) == 'r') {
							piecePosition[x] = -1;
							return true;
						}
						else if (playerColor(x) == 'b') {
							piecePosition[x] = -2;
							return true;
						}
						else if (playerColor(x) == 'g') {
							return false;
						}
						else if (playerColor(x) == 'y') {
							piecePosition[x] = -4;
							return true;
						}
					case 'y':
						if (playerColor(x) == 'r') {
							piecePosition[x] = -1;
							return true;
						}
						else if (playerColor(x) == 'b') {
							piecePosition[x] = -2;
							return true;
						}
						else if (playerColor(x) == 'g') {
							piecePosition[x] = -3;
							return true;
						}
						else if (playerColor(x) == 'y') {
							return false;
						}
					}
				}
			}
		}
	}
}
void sliderKillCheck(char pieceColor, int sliderPositionCheck) { //Checks if there are any kills on a slider path
	for (int x = 0; x < (playerCount * 4); x++) {
		if (piecePosition[x] == sliderPositionCheck && (pieceColor != playerColor(x))) {
			switch (playerColor(x)) {
			case 'r':
				piecePosition[x] = -1;
				break;
			case 'b':
				piecePosition[x] = -2;
				break;
			case 'g':
				piecePosition[x] = -3;
				break;
			case 'y':
				piecePosition[x] = -4;
				break;
			}
		}
	}
	return;
}
bool sliderCheckAndMove(int currentPlayingPiecePosition, int currentPieceNum) { //Checks if a pice is on the start of a slider and will move them to the end while also checking for kills and legality
	switch (playerColor(currentPieceNum)) {
	case 'r':
		if (currentPlayingPiecePosition == 13 && (!(checkValidOrKillMovement(16, currentPieceNum)))) {
			sliderKillCheck((playerColor(currentPieceNum)), 14);
			sliderKillCheck((playerColor(currentPieceNum)), 15);
			sliderKillCheck((playerColor(currentPieceNum)), 16);
			piecePosition[currentPieceNum] = 16;
			return true;
		}
		else if (currentPlayingPiecePosition == 21 && ((checkValidOrKillMovement(25, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 22);
			sliderKillCheck((playerColor(currentPieceNum)), 23);
			sliderKillCheck((playerColor(currentPieceNum)), 24);
			sliderKillCheck((playerColor(currentPieceNum)), 25);
			piecePosition[currentPieceNum] = 25;
			return true;
		}
		else if (currentPlayingPiecePosition == 28 && ((checkValidOrKillMovement(31, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 29);
			sliderKillCheck((playerColor(currentPieceNum)), 30);
			sliderKillCheck((playerColor(currentPieceNum)), 31);
			piecePosition[currentPieceNum] = 31;
			return true;
		}
		else if (currentPlayingPiecePosition == 36 && ((checkValidOrKillMovement(40, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 37);
			sliderKillCheck((playerColor(currentPieceNum)), 38);
			sliderKillCheck((playerColor(currentPieceNum)), 39);
			sliderKillCheck((playerColor(currentPieceNum)), 40);
			piecePosition[currentPieceNum] = 40;
			return true;
		}
		else if (currentPlayingPiecePosition == 43 && ((checkValidOrKillMovement(46, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 44);
			sliderKillCheck((playerColor(currentPieceNum)), 45);
			sliderKillCheck((playerColor(currentPieceNum)), 46);
			piecePosition[currentPieceNum] = 46;
			return true;
		}
		else if (currentPlayingPiecePosition == 51 && ((checkValidOrKillMovement(55, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 52);
			sliderKillCheck((playerColor(currentPieceNum)), 53);
			sliderKillCheck((playerColor(currentPieceNum)), 54);
			sliderKillCheck((playerColor(currentPieceNum)), 55);
			piecePosition[currentPieceNum] = 55;
			return true;
		}
		else if (currentPlayingPiecePosition == 58) {
			return checkValidOrKillMovement(58, currentPieceNum);
		}
		else if (currentPlayingPiecePosition == 6) {
			return checkValidOrKillMovement(6, currentPieceNum);
		}
		else {
			return false;
		}
	case 'b':
		if (currentPlayingPiecePosition == 58 && ((checkValidOrKillMovement(1, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 58);
			sliderKillCheck((playerColor(currentPieceNum)), 0);
			sliderKillCheck((playerColor(currentPieceNum)), 1);
			piecePosition[currentPieceNum] = 1;
			return true;
		}
		else if (currentPlayingPiecePosition == 6 && ((checkValidOrKillMovement(10, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 7);
			sliderKillCheck((playerColor(currentPieceNum)), 8);
			sliderKillCheck((playerColor(currentPieceNum)), 9);
			sliderKillCheck((playerColor(currentPieceNum)), 10);
			piecePosition[currentPieceNum] = 10;
			return true;
		}
		else if (currentPlayingPiecePosition == 28 && ((checkValidOrKillMovement(31, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 29);
			sliderKillCheck((playerColor(currentPieceNum)), 30);
			sliderKillCheck((playerColor(currentPieceNum)), 31);
			piecePosition[currentPieceNum] = 31;
			return true;
		}
		else if (currentPlayingPiecePosition == 36 && ((checkValidOrKillMovement(40, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 37);
			sliderKillCheck((playerColor(currentPieceNum)), 38);
			sliderKillCheck((playerColor(currentPieceNum)), 39);
			sliderKillCheck((playerColor(currentPieceNum)), 40);
			piecePosition[currentPieceNum] = 40;
			return true;
		}
		else if (currentPlayingPiecePosition == 43 && ((checkValidOrKillMovement(46, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 44);
			sliderKillCheck((playerColor(currentPieceNum)), 45);
			sliderKillCheck((playerColor(currentPieceNum)), 46);
			piecePosition[currentPieceNum] = 46;
			return true;
		}
		else if (currentPlayingPiecePosition == 51 && ((checkValidOrKillMovement(55, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 52);
			sliderKillCheck((playerColor(currentPieceNum)), 53);
			sliderKillCheck((playerColor(currentPieceNum)), 54);
			sliderKillCheck((playerColor(currentPieceNum)), 55);
			piecePosition[currentPieceNum] = 55;
			return true;
		}
		else if (currentPlayingPiecePosition == 13) {
			return checkValidOrKillMovement(13, currentPieceNum);
		}
		else if (currentPlayingPiecePosition == 21) {
			return checkValidOrKillMovement(21, currentPieceNum);
		}
		else {
			return false;
		}
	case 'g':
		if (currentPlayingPiecePosition == 58 && ((checkValidOrKillMovement(1, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 58);
			sliderKillCheck((playerColor(currentPieceNum)), 0);
			sliderKillCheck((playerColor(currentPieceNum)), 1);
			piecePosition[currentPieceNum] = 1;
			return true;
		}
		else if (currentPlayingPiecePosition == 6 && ((checkValidOrKillMovement(10, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 7);
			sliderKillCheck((playerColor(currentPieceNum)), 8);
			sliderKillCheck((playerColor(currentPieceNum)), 9);
			sliderKillCheck((playerColor(currentPieceNum)), 10);
			piecePosition[currentPieceNum] = 10;
			return true;
		}
		else if (currentPlayingPiecePosition == 13 && (!(checkValidOrKillMovement(16, currentPieceNum)))) {
			sliderKillCheck((playerColor(currentPieceNum)), 14);
			sliderKillCheck((playerColor(currentPieceNum)), 15);
			sliderKillCheck((playerColor(currentPieceNum)), 16);
			piecePosition[currentPieceNum] = 16;
			return true;
		}
		else if (currentPlayingPiecePosition == 21 && ((checkValidOrKillMovement(25, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 22);
			sliderKillCheck((playerColor(currentPieceNum)), 23);
			sliderKillCheck((playerColor(currentPieceNum)), 24);
			sliderKillCheck((playerColor(currentPieceNum)), 25);
			piecePosition[currentPieceNum] = 25;
			return true;
		}
		else if (currentPlayingPiecePosition == 43 && ((checkValidOrKillMovement(46, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 44);
			sliderKillCheck((playerColor(currentPieceNum)), 45);
			sliderKillCheck((playerColor(currentPieceNum)), 46);
			piecePosition[currentPieceNum] = 46;
			return true;
		}
		else if (currentPlayingPiecePosition == 51 && ((checkValidOrKillMovement(55, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 52);
			sliderKillCheck((playerColor(currentPieceNum)), 53);
			sliderKillCheck((playerColor(currentPieceNum)), 54);
			sliderKillCheck((playerColor(currentPieceNum)), 55);
			piecePosition[currentPieceNum] = 55;
			return true;
		}
		else if (currentPlayingPiecePosition == 28) {
			return checkValidOrKillMovement(28, currentPieceNum);
		}
		else if (currentPlayingPiecePosition == 36) {
			return checkValidOrKillMovement(36, currentPieceNum);
		}
		else {
			return false;
		}
	case 'y':
		if (currentPlayingPiecePosition == 58 && ((checkValidOrKillMovement(1, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 58);
			sliderKillCheck((playerColor(currentPieceNum)), 0);
			sliderKillCheck((playerColor(currentPieceNum)), 1);
			piecePosition[currentPieceNum] = 1;
			return true;
		}
		else if (currentPlayingPiecePosition == 6 && ((checkValidOrKillMovement(10, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 7);
			sliderKillCheck((playerColor(currentPieceNum)), 8);
			sliderKillCheck((playerColor(currentPieceNum)), 9);
			sliderKillCheck((playerColor(currentPieceNum)), 10);
			piecePosition[currentPieceNum] = 10;
			return true;
		}
		else if (currentPlayingPiecePosition == 13 && (!(checkValidOrKillMovement(16, currentPieceNum)))) {
			sliderKillCheck((playerColor(currentPieceNum)), 14);
			sliderKillCheck((playerColor(currentPieceNum)), 15);
			sliderKillCheck((playerColor(currentPieceNum)), 16);
			piecePosition[currentPieceNum] = 16;
			return true;
		}
		else if (currentPlayingPiecePosition == 21 && ((checkValidOrKillMovement(25, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 22);
			sliderKillCheck((playerColor(currentPieceNum)), 23);
			sliderKillCheck((playerColor(currentPieceNum)), 24);
			sliderKillCheck((playerColor(currentPieceNum)), 25);
			piecePosition[currentPieceNum] = 25;
			return true;
		}
		else if (currentPlayingPiecePosition == 28 && ((checkValidOrKillMovement(31, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 29);
			sliderKillCheck((playerColor(currentPieceNum)), 30);
			sliderKillCheck((playerColor(currentPieceNum)), 31);
			piecePosition[currentPieceNum] = 31;
			return true;
		}
		else if (currentPlayingPiecePosition == 36 && ((checkValidOrKillMovement(40, currentPieceNum)) != false)) {
			sliderKillCheck((playerColor(currentPieceNum)), 37);
			sliderKillCheck((playerColor(currentPieceNum)), 38);
			sliderKillCheck((playerColor(currentPieceNum)), 39);
			sliderKillCheck((playerColor(currentPieceNum)), 40);
			piecePosition[currentPieceNum] = 40;
			return true;
		}
		else if (currentPlayingPiecePosition == 43) {
			return checkValidOrKillMovement(43, currentPieceNum);
		}
		else if (currentPlayingPiecePosition == 51) {
			return checkValidOrKillMovement(51, currentPieceNum);
		}
		else {
			return false;
		}
	}
}
int cardDraw() {
	int cardNumber;
	bool availableCard = false;
	if (one == 0 && two == 0 && three == 0 && four == 0 && five == 0 && six == 0 && seven == 0 && eight == 0 && nine == 0 && ten == 0 && eleven == 0 && twelve == 0 && sorry == 0) {
		one = (5);
		two = (4);
		three = (4);
		four = (4);
		five = (4);
		six = (4);
		seven = (4);
		eight = (4);
		nine = (4);
		ten = (4);
		eleven = (4);
		twelve = (4);
		sorry = (4);
	}
	do {
		std::mt19937 rng;
		rng.seed(std::random_device()());
		std::uniform_int_distribution<std::mt19937::result_type> random(1, 13); // distribution in range [1, 6] 
		cardNumber = random(rng);
		switch (cardNumber) {
		case 1:
			if (one >= 1) {
				one--;
				availableCard = true;
			}
			break;
		case 2:
			if (two >= 1) {
				two--;
				availableCard = true;
			}
			break;
		case 3:
			if (three >= 1) {
				three--;
				availableCard = true;
			}
			break;
		case 4:
			if (four >= 1) {
				four--;
				availableCard = true;
			}
			break;
		case 5:
			if (five >= 1) {
				five--;
				availableCard = true;
			}
			break;
		case 6:
			if (six >= 1) {
				six--;
				availableCard = true;
			}
			break;
		case 7:
			if (seven >= 1) {
				seven--;
				availableCard = true;
			}
			break;
		case 8:
			if (eight >= 1) {
				eight--;
				availableCard = true;
			}
			break;
		case 9:
			if (nine >= 1) {
				nine--;
				availableCard = true;
			}
			break;
		case 10:
			if (ten >= 1) {
				ten--;
				availableCard = true;
			}
			break;
		case 11:
			if (eleven >= 1) {
				eleven--;
				availableCard = true;
			}
			break;
		case 12:
			if (twelve >= 1) {
				twelve--;
				availableCard = true;
			}
			break;
		case 13:
			if (sorry >= 1) {
				sorry--;
				availableCard = true;
			}
			break;
		}
	} while (availableCard == false);
	return cardNumber;
}
char playerColorTurn(int cardNumber) {
	static int turn;
	if (playerCount == 4) {
		turn++;
		if (turn > 4) {
			turn = 1;
		}
	}
	else if (playerCount == 3) {
		turn++;
		if (turn > 3) {
			turn = 1;
		}
	}
	else if (playerCount == 2) {
		turn++;
		if (turn > 2) {
			turn = 1;
		}
	}

	switch (turn) {
	case 1:
		if (cardNumber == 2) {
			turn--;
		}
		return 'r';
		break;
	case 2:
		if (cardNumber == 2) {
			turn--;
		}
		return 'b';
		break;
	case 3:
		if (cardNumber == 2) {
			turn--;
		}
		return 'g';
		break;
	case 4:
		if (cardNumber == 2) {
			turn--;
		}
		return 'y';
		break;
	}
}
int playerMovementInput(char colorOfPlayer) {
	std::cout << "Input what piece you would like to move." << std::endl;
	bool intCheck = false;
	int input = 0;
	do {
		std::cout << "Make sure it's either 1, 2, 3 or 4!\n";
		std::cin >> input;
		if ((input == 1 || input == 2 || input == 3 || input == 4)) {
			intCheck = true;
		}
		std::cin.clear();
		std::cin.ignore();
	} while (!(intCheck));
	switch (input) {
	case 1:
		if (colorOfPlayer == 'r') {
			return 0;
		}
		else if (colorOfPlayer == 'b') {
			return 4;
		}
		else if (colorOfPlayer == 'g') {
			return 8;
		}
		else if (colorOfPlayer == 'y') {
			return 12;
		}
	case 2:
		if (colorOfPlayer == 'r') {
			return 1;
		}
		else if (colorOfPlayer == 'b') {
			return 5;
		}
		else if (colorOfPlayer == 'g') {
			return 9;
		}
		else if (colorOfPlayer == 'y') {
			return 13;
		}
	case 3:
		if (colorOfPlayer == 'r') {
			return 2;
		}
		else if (colorOfPlayer == 'b') {
			return 6;
		}
		else if (colorOfPlayer == 'g') {
			return 10;
		}
		else if (colorOfPlayer == 'y') {
			return 14;
		}
	case 4:
		if (colorOfPlayer == 'r') {
			return 3;
		}
		else if (colorOfPlayer == 'b') {
			return 7;
		}
		else if (colorOfPlayer == 'g') {
			return 11;
		}
		else if (colorOfPlayer == 'y') {
			return 15;
		}
	}
}
bool checkIfPlayerWon(char colorOfPlayer) {
	switch (colorOfPlayer) {
	case 'r':
		if (piecePosition[0] == 66 && piecePosition[1] == 66 && piecePosition[2] == 66 && piecePosition[3] == 66) {
			return true;
		}
		else {
			return false;
		}
	case 'b':
		if (piecePosition[4] == 72 && piecePosition[5] == 72 && piecePosition[6] == 72 && piecePosition[7] == 72) {
			return true;
		}
		else {
			return false;
		}
	case 'g':
		if (piecePosition[8] == 78 && piecePosition[9] == 78 && piecePosition[10] == 78 && piecePosition[11] == 78) {
			return true;
		}
		else {
			return false;
		}
	case 'y':
		if (piecePosition[12] == 84 && piecePosition[13] == 84 && piecePosition[14] == 84 && piecePosition[15] == 84) {
			return true;
		}
		else {
			return false;
		}
	}
}
void sorryCardActivation(char currentPlayerColor, int currentPieceNumber) { //Function for sorry card
	bool pieceInStart = false;
	bool pieceOnBoard = false;
	for (int x = 0; x < playerCount * 4; x++) {
		if (currentPlayerColor == playerColor(x)) {
			switch (currentPlayerColor) {
			case 'r':
				if (piecePosition[x] == -1) {
					pieceInStart = true;
				} break;
			case 'b':
				if (piecePosition[x] == -2) {
					pieceInStart = true;
				} break;
			case 'g':
				if (piecePosition[x] == -3) {
					pieceInStart = true;
				} break;
			case 'y':
				if (piecePosition[x] == -4) {
					pieceInStart = true;
				} break;
			}
		}
		if (currentPlayerColor != playerColor(x)) {
			switch (currentPlayerColor) {
			case 'r':
				if (piecePosition[x] >= 0 && piecePosition[x] <= 59) {
					pieceOnBoard = true;
				} break;
			case 'b':
				if (piecePosition[x] >= 0 && piecePosition[x] <= 59) {
					pieceOnBoard = true;
				} break;
			case 'g':
				if (piecePosition[x] >= 0 && piecePosition[x] <= 59) {
					pieceOnBoard = true;
				} break;
			case 'y':
				if (piecePosition[x] >= 0 && piecePosition[x] <= 59) {
					pieceOnBoard = true;
				} break;
			}
		}
	}
	if (pieceOnBoard == true && pieceInStart == true) {
		int currentClosestDistance = 999;
		int currentClosestPieceNum;
		for (int j = 0; j < playerCount * 4; j++) {
			if (currentPlayerColor != playerColor(j)) {
				if (piecePosition[j] >= 0 && piecePosition[j] <= 59) {
					int positionToTest;
					switch (currentPlayerColor) {
					case 'r':
						positionToTest = 59 - piecePosition[j];
						if (positionToTest >= 0) {
							if (positionToTest < currentClosestDistance) {
								currentClosestDistance = positionToTest;
								currentClosestPieceNum = j;
							}
						}
						if (positionToTest < 0 && currentClosestDistance == 999) {
								currentClosestDistance = positionToTest;
								currentClosestPieceNum = j;
							}
						if (positionToTest < 0 && currentClosestDistance < 0) {
							if (positionToTest < currentClosestDistance) {
								currentClosestDistance = positionToTest;
								currentClosestPieceNum = j;
							}
						}
						break;
					case 'b':
						positionToTest = 14 - piecePosition[j];
						if (positionToTest >= 0) {
							if (positionToTest < currentClosestDistance) {
								currentClosestDistance = positionToTest;
								currentClosestPieceNum = j;
							}
						}
						if (positionToTest < 0 && currentClosestDistance == 999) {
							currentClosestDistance = positionToTest;
							currentClosestPieceNum = j;
						}
						if (positionToTest < 0 && currentClosestDistance < 0) {
							if (positionToTest < currentClosestDistance) {
								currentClosestDistance = positionToTest;
								currentClosestPieceNum = j;
							}
						}
						break;
					case 'g':
						positionToTest = 29 - piecePosition[j];
						if (positionToTest >= 0) {
							if (positionToTest < currentClosestDistance) {
								currentClosestDistance = positionToTest;
								currentClosestPieceNum = j;
							}
						}
						if (positionToTest < 0 && currentClosestDistance == 999) {
							currentClosestDistance = positionToTest;
							currentClosestPieceNum = j;
						}
						if (positionToTest < 0 && currentClosestDistance < 0) {
							if (positionToTest < currentClosestDistance) {
								currentClosestDistance = positionToTest;
								currentClosestPieceNum = j;
							}
						}
						break;
					case 'y':
						positionToTest = 44 - piecePosition[j];
						if (positionToTest >= 0) {
							if (positionToTest < currentClosestDistance) {
								currentClosestDistance = positionToTest;
								currentClosestPieceNum = j;
							}
						}
						if (positionToTest < 0 && currentClosestDistance == 999) {
							currentClosestDistance = positionToTest;
							currentClosestPieceNum = j;
						}
						if (positionToTest < 0 && currentClosestDistance < 0) {
							if (positionToTest < currentClosestDistance) {
								currentClosestDistance = positionToTest;
								currentClosestPieceNum = j;
							}
						}
					}
				}
			}
		}
		piecePosition[currentPieceNumber] = piecePosition[currentClosestPieceNum];
		switch (playerColor(currentClosestPieceNum)) {
		case 'r':
			piecePosition[currentClosestPieceNum] = -1;
			break;
		case 'b':
			piecePosition[currentClosestPieceNum] = -2;
			break;
		case 'g':
			piecePosition[currentClosestPieceNum] = -3;
			break;
		case 'y':
			piecePosition[currentClosestPieceNum] = -4;
			break;
		}
	}
}
void swapPosition(char playerColorCheck) {
	bool intCheck = false;
	bool intCheck2 = false;
	int input = 0;
	int input2 = 0;
	do {
		std::cout << "What two would you like to swap? \nType any number (Your piece) from 1 to 16:\n1-Red 1, 2-Red 2, 3-Red 3, 4-Red 4                         5-Blue 1, 6-Blue 2, 7-Blue 3, 8-Blue 4\n";
		std::cout << "9-Green 1, 10-Green 2, 11-Green 3, 12-Green 4              13-Yellow 1, 14-Yellow 2, 15-Yellow 3, 16-Yellow 4\n";
		std::cin >> input;
		if ((input == 1 || input == 2 || input == 3 || input == 4 || input == 5 || input == 6 || input == 7 || input == 8 || input == 9 || input == 10 || input == 11 || input == 12 || input == 13 || input == 14 || input == 15 || input == 16)) {
			intCheck = true;
		}
		std::cin.clear();
		std::cin.ignore();
	} while (!(intCheck));
	do {
		std::cout << "What two would you like to swap? \nType any number (Any piece you wish to swap with) from 1 to 16:\n 1 - Red 1, 2 - Red 2, 3 - Red 3, 4 - Red 4                5-Blue 1, 6 - Blue 2, 7 - Blue 3, 8 - Blue 4\n";
		std::cout << "9-Green 1, 10-Green 2, 11-Green 3, 12-Green 4              13-Yellow 1, 14-Yellow 2, 15-Yellow 3, 16-Yellow 4\n";
		std::cin >> input2;
		if ((input2 == 1 || input2 == 2 || input2 == 3 || input2 == 4 || input2 == 5 || input2 == 6 || input2 == 7 || input2 == 8 || input2 == 9 || input2 == 10 || input2 == 11 || input2 == 12 || input2 == 13 || input2 == 14 || input2 == 15 || input2 == 16)) {
			intCheck2 = true;
		}
		std::cin.clear();
		std::cin.ignore();
	} while (!(intCheck2));
	input--;
	input2--;
	if (piecePosition[input] == -1 || piecePosition[input] == -2 || piecePosition[input] == -3 || piecePosition[input] == -4 || piecePosition[input2] == -1 || piecePosition[input2] == -2 || piecePosition[input2] == -3 || piecePosition[input2] == -4 || piecePosition[input2] > 59 || piecePosition[input] > 59) {
		std::cout << "Invalid Swap Detected!\n";
		return;
	}
	if (playerColor(input) != playerColorCheck) {
		std::cout << "Invalid Swap Detected!\n";
		return;
	}
	int tempNumStoring;
	tempNumStoring = piecePosition[input];
	piecePosition[input] = piecePosition[input2];
	piecePosition[input2] = tempNumStoring;
	return;
}
bool userSwapOrMove(char playerColorCheck) {
	bool intCheck = false;
	int input = 0;
	do {
		std::cout << "Would you like to swap? Type 1 for yes or 2 for no.\n";// 1, 2, 3 or 4!\n";
		std::cin >> input;
		if ((input == 1 || input == 2)) {
			intCheck = true;
		}
		std::cin.clear();
		std::cin.ignore();
	} while (!(intCheck));
	switch (input) {
	case 1:
		swapPosition(playerColorCheck);
		return true;
	case 2:
		return false;
	}
}
void displayBoard() {
	std::string gameBoard =
		" _______________________________________________________________________________\n"
		"|    |>   |>   |>   |>   |    |    |    |    |>   |>   |>   |>   |>   |    |    |\n"
		" _____________________^_________________________________________________________\n"
		"|    |	  |    |                                                           |V   |\n"
		" ____	   ____       Start                   ~~~~ ____ ____ ____ ____ ____ ____\n"
		"|   ^|	  |    |                             {    }    |    |    |    |    |V   |\n"
		" ____	   ____                               ~~~~ ____ ____ ____ ____ ____ ____\n"
		"|   ^|	  |    |                                                           |V   |\n"
		" ____	   ____                                                             ____\n"
		"|   ^|	  |    |                                                           >V   |\n"
		" ____	   ____                                                      Start  ____\n"
		"|   ^|	  |    |                                                           |    |\n"
		" ____	   ~~~~                                                             ____\n"
		"|   ^|	  {    }                                                           |    |\n"
		" ____	   ~~~~                                                             ____\n"
		"|    |                                                                     |    |\n"
		" ____                                                                       ____\n"
		"|    |                                                                     |    |\n"
		" ____                                                             ~~~~      ____\n"
		"|    |                                                           {    }    |V   |\n"
		" ____                                                             ~~~~      ____\n"
		"|    |   Start                                                   |    |    |V   |\n"
		" ____                                                             ____      ____\n"
		"|   ^<                                                           |    |    |V   |\n"
		" ____                                                             ____      ____\n"
		"|   ^|                                                           |    |    |V   |\n"
		" ____ ____ ____ ____ ____ ____ ~~~~                               ____      ____\n"
		"|   ^|    |    |    |    |    {    }                             |    |    |V   |\n"
		" ____ ____ ____ ____ ____ ____ ~~~~                    Start      ____      ____\n"
		"|   ^|                                                           |    |    |    |\n"
		" ________________________________________________________V______________________\n"
		"|    |    |   <|   <|   <|   <|   <|    |    |    |    |   <|   <|   <|   <|    |\n"
		" _______________________________________________________________________________\n";
	int y = 0;

	for (int x = 0; x < (sizeof(piecePosition) / sizeof(*piecePosition)); x++) {
		std::string numToInsert;
		std::string charToInsert;
		if (y == 4) {
			y = 0;
		}
		y++;
		if (y == 1) {
			numToInsert = "1";
		}
		if (y == 2) {
			numToInsert = "2";
		}
		if (y == 3) {
			numToInsert = "3";
		}
		if (y == 4) {
			numToInsert = "4";
		}
		if (playerColor(x) == 'r') {
			charToInsert = "R";
		}
		if (playerColor(x) == 'b') {
			charToInsert = "B";
		}
		if (playerColor(x) == 'g') {
			charToInsert = "G";
		}
		if (playerColor(x) == 'y') {
			charToInsert = "Y";
		}
		switch (piecePosition[x]) {
		case 1:
			gameBoard.replace(104, 1, numToInsert);
			gameBoard.replace(105, 1, charToInsert);
			break;
		case 2:
			gameBoard.replace(109, 1, numToInsert);
			gameBoard.replace(110, 1, charToInsert);
			break;
		case 3:
			gameBoard.replace(114, 1, numToInsert);
			gameBoard.replace(115, 1, charToInsert);
			break;
		case 4:
			gameBoard.replace(119, 1, numToInsert);
			gameBoard.replace(120, 1, charToInsert);
			break;
		case 5:
			gameBoard.replace(124, 1, numToInsert);
			gameBoard.replace(125, 1, charToInsert);
			break;
		case 6:
			gameBoard.replace(129, 1, numToInsert);
			gameBoard.replace(130, 1, charToInsert);
		case 7:
			gameBoard.replace(134, 1, numToInsert);
			gameBoard.replace(135, 1, charToInsert);
			break;
		case 8:
			gameBoard.replace(139, 1, numToInsert);
			gameBoard.replace(140, 1, charToInsert);
			break;
		case 9:
			gameBoard.replace(144, 1, numToInsert);
			gameBoard.replace(145, 1, charToInsert);
			break;
		case 10:
			gameBoard.replace(149, 1, numToInsert);
			gameBoard.replace(150, 1, charToInsert);
			break;
		case 11:
			gameBoard.replace(154, 1, numToInsert);
			gameBoard.replace(155, 1, charToInsert);
			break;
		case 12:
			gameBoard.replace(159, 1, numToInsert);
			gameBoard.replace(160, 1, charToInsert);
			break;
		case 13:
			gameBoard.replace(321, 1, numToInsert);
			gameBoard.replace(322, 1, charToInsert);
			break;
		case 14:
			gameBoard.replace(481, 1, numToInsert);
			gameBoard.replace(482, 1, charToInsert);
			break;
		case 15:
			gameBoard.replace(641, 1, numToInsert);
			gameBoard.replace(642, 1, charToInsert);
			break;
		case 16:
			gameBoard.replace(801, 1, numToInsert);
			gameBoard.replace(802, 1, charToInsert);
			break;
		case 17:
			gameBoard.replace(961, 1, numToInsert);
			gameBoard.replace(962, 1, charToInsert);
			break;
		case 18:
			gameBoard.replace(1121, 1, numToInsert);
			gameBoard.replace(1122, 1, charToInsert);
			break;
		case 19:
			gameBoard.replace(1282, 1, numToInsert);
			gameBoard.replace(1283, 1, charToInsert);
			break;
		case 20:
			gameBoard.replace(1445, 1, numToInsert);
			gameBoard.replace(1446, 1, charToInsert);
			break;
		case 21:
			gameBoard.replace(1608, 1, numToInsert);
			gameBoard.replace(1609, 1, charToInsert);
			break;
		case 22:
			gameBoard.replace(1771, 1, numToInsert);
			gameBoard.replace(1772, 1, charToInsert);
			break;
		case 23:
			gameBoard.replace(1934, 1, numToInsert);
			gameBoard.replace(1935, 1, charToInsert);
			break;
		case 24:
			gameBoard.replace(2097, 1, numToInsert);
			gameBoard.replace(2098, 1, charToInsert);
			break;
		case 25:
			gameBoard.replace(2260, 1, numToInsert);
			gameBoard.replace(2261, 1, charToInsert);
			break;
		case 26:
			gameBoard.replace(2423, 1, numToInsert);
			gameBoard.replace(2424, 1, charToInsert);
			break;
		case 27:
			gameBoard.replace(2586, 1, numToInsert);
			gameBoard.replace(2587, 1, charToInsert);
			break;
		case 28:
			gameBoard.replace(2579, 1, numToInsert);
			gameBoard.replace(2580, 1, charToInsert);
			break;
		case 29:
			gameBoard.replace(2574, 1, numToInsert);
			gameBoard.replace(2575, 1, charToInsert);
			break;
		case 30:
			gameBoard.replace(2569, 1, numToInsert);
			gameBoard.replace(2570, 1, charToInsert);
			break;
		case 31:
			gameBoard.replace(2564, 1, numToInsert);
			gameBoard.replace(2565, 1, charToInsert);
			break;
		case 32:
			gameBoard.replace(2559, 1, numToInsert);
			gameBoard.replace(2560, 1, charToInsert);
			break;
		case 33:
			gameBoard.replace(2554, 1, numToInsert);
			gameBoard.replace(2555, 1, charToInsert);
			break;
		case 34:
			gameBoard.replace(2549, 1, numToInsert);
			gameBoard.replace(2550, 1, charToInsert);
			break;
		case 35:
			gameBoard.replace(2544, 1, numToInsert);
			gameBoard.replace(2545, 1, charToInsert);
			break;
		case 36:
			gameBoard.replace(2539, 1, numToInsert);
			gameBoard.replace(2540, 1, charToInsert);
			break;
		case 37:
			gameBoard.replace(2534, 1, numToInsert);
			gameBoard.replace(2535, 1, charToInsert);
			break;
		case 38:
			gameBoard.replace(2529, 1, numToInsert);
			gameBoard.replace(2530, 1, charToInsert);
			break;
		case 39:
			gameBoard.replace(2524, 1, numToInsert);
			gameBoard.replace(2525, 1, charToInsert);
			break;
		case 40:
			gameBoard.replace(2519, 1, numToInsert);
			gameBoard.replace(2520, 1, charToInsert);
			break;
		case 41:
			gameBoard.replace(2514, 1, numToInsert);
			gameBoard.replace(2515, 1, charToInsert);
			break;
		case 42:
			gameBoard.replace(2509, 1, numToInsert);
			gameBoard.replace(2510, 1, charToInsert);
			break;
		case 43:
			gameBoard.replace(2346, 1, numToInsert);
			gameBoard.replace(2347, 1, charToInsert);
			break;
		case 44:
			gameBoard.replace(2183, 1, numToInsert);
			gameBoard.replace(2184, 1, charToInsert);
			break;
		case 45:
			gameBoard.replace(2020, 1, numToInsert);
			gameBoard.replace(2021, 1, charToInsert);
			break;
		case 46:
			gameBoard.replace(1857, 1, numToInsert);
			gameBoard.replace(1858, 1, charToInsert);
			break;
		case 47:
			gameBoard.replace(1694, 1, numToInsert);
			gameBoard.replace(1695, 1, charToInsert);
			break;
		case 48:
			gameBoard.replace(1531, 1, numToInsert);
			gameBoard.replace(1532, 1, charToInsert);
			break;
		case 49:
			gameBoard.replace(1368, 1, numToInsert);
			gameBoard.replace(1369, 1, charToInsert);
			break;
		case 50:
			gameBoard.replace(1205, 1, numToInsert);
			gameBoard.replace(1206, 1, charToInsert);
			break;
		case 51:
			gameBoard.replace(1045, 1, numToInsert);
			gameBoard.replace(1046, 1, charToInsert);
			break;
		case 52:
			gameBoard.replace(885, 1, numToInsert);
			gameBoard.replace(886, 1, charToInsert);
			break;
		case 53:
			gameBoard.replace(725, 1, numToInsert);
			gameBoard.replace(726, 1, charToInsert);
			break;
		case 54:
			gameBoard.replace(565, 1, numToInsert);
			gameBoard.replace(566, 1, charToInsert);
			break;
		case 55:
			gameBoard.replace(405, 1, numToInsert);
			gameBoard.replace(406, 1, charToInsert);
			break;
		case 56:
			gameBoard.replace(245, 1, numToInsert);
			gameBoard.replace(246, 1, charToInsert);
			break;
		case 57:
			gameBoard.replace(82, 1, numToInsert);
			gameBoard.replace(83, 1, charToInsert);
			break;
		case 58:
			gameBoard.replace(89, 1, numToInsert);
			gameBoard.replace(90, 1, charToInsert);
			break;
		case 59:
			gameBoard.replace(94, 1, numToInsert);
			gameBoard.replace(95, 1, charToInsert);
			break;
		case 0:
			gameBoard.replace(99, 1, numToInsert);
			gameBoard.replace(100, 1, charToInsert);
			break;
		case 61:
			gameBoard.replace(255, 1, numToInsert);
			gameBoard.replace(256, 1, charToInsert);
			break;
		case 62:
			gameBoard.replace(415, 1, numToInsert);
			gameBoard.replace(416, 1, charToInsert);
			break;
		case 63:
			gameBoard.replace(575, 1, numToInsert);
			gameBoard.replace(576, 1, charToInsert);
			break;
		case 64:
			gameBoard.replace(735, 1, numToInsert);
			gameBoard.replace(736, 1, charToInsert);
			break;
		case 65:
			gameBoard.replace(895, 1, numToInsert);
			gameBoard.replace(896, 1, charToInsert);
			break;
		case 66:
			gameBoard.replace(1055, 1, numToInsert);
			gameBoard.replace(1056, 1, charToInsert);
			break;
		case 67:
			gameBoard.replace(475, 1, numToInsert);
			gameBoard.replace(476, 1, charToInsert);
			break;
		case 68:
			gameBoard.replace(470, 1, numToInsert);
			gameBoard.replace(471, 1, charToInsert);
			break;
		case 69:
			gameBoard.replace(465, 1, numToInsert);
			gameBoard.replace(466, 1, charToInsert);
			break;
		case 70:
			gameBoard.replace(460, 1, numToInsert);
			gameBoard.replace(461, 1, charToInsert);
			break;
		case 71:
			gameBoard.replace(455, 1, numToInsert);
			gameBoard.replace(456, 1, charToInsert);
			break;
		case 72:
			gameBoard.replace(450, 1, numToInsert);
			gameBoard.replace(451, 1, charToInsert);
			break;
		case 73:
			gameBoard.replace(1597, 1, numToInsert);
			gameBoard.replace(1598, 1, charToInsert);
			break;
		case 74:
			gameBoard.replace(1760, 1, numToInsert);
			gameBoard.replace(1761, 1, charToInsert);
			break;
		case 75:
			gameBoard.replace(1923, 1, numToInsert);
			gameBoard.replace(1924, 1, charToInsert);
			break;
		case 76:
			gameBoard.replace(2086, 1, numToInsert);
			gameBoard.replace(2087, 1, charToInsert);
			break;
		case 77:
			gameBoard.replace(2249, 1, numToInsert);
			gameBoard.replace(2250, 1, charToInsert);
			break;
		case 78:
			gameBoard.replace(2412, 1, numToInsert);
			gameBoard.replace(2413, 1, charToInsert);
			break;
		case 79:
			gameBoard.replace(2189, 1, numToInsert);
			gameBoard.replace(2190, 1, charToInsert);
			break;
		case 80:
			gameBoard.replace(2194, 1, numToInsert);
			gameBoard.replace(2195, 1, charToInsert);
			break;
		case 81:
			gameBoard.replace(2199, 1, numToInsert);
			gameBoard.replace(2200, 1, charToInsert);
			break;
		case 82:
			gameBoard.replace(2204, 1, numToInsert);
			gameBoard.replace(2205, 1, charToInsert);
			break;
		case 83:
			gameBoard.replace(2209, 1, numToInsert);
			gameBoard.replace(2210, 1, charToInsert);
			break;
		case 84:
			gameBoard.replace(2214, 1, numToInsert);
			gameBoard.replace(2215, 1, charToInsert);
			break;
		case -1:
			gameBoard.replace(266, 1, numToInsert);
			gameBoard.replace(267, 1, charToInsert);
			break;
		case -2:
			gameBoard.replace(795, 1, numToInsert);
			gameBoard.replace(796, 1, charToInsert);
			break;
		case -4:
			gameBoard.replace(1863, 1, numToInsert);
			gameBoard.replace(1864, 1, charToInsert);
			break;
		case -3:
			gameBoard.replace(2402, 1, numToInsert);
			gameBoard.replace(2403, 1, charToInsert);
			break;
		}

	}

	std::cout << gameBoard;
}
char gamePlayingFunction() {
	std::cout << "How many players?\n";
	std::cin >> playerCount;
	playerDataGenerator(playerCount);
	boardGenerator();
	char currentPlayingColor;
	do {
		displayBoard();
		//Draws the card
		//Takes input from user to allow the movement and decision of what piece to move
		int cardDrawn = cardDraw();
		bool didSwitch = false;
		currentPlayingColor = playerColorTurn(cardDrawn);
		std::cout << "\nYou drew: " << (cardDrawn) << std::endl;
		std::string color;
		switch (currentPlayingColor) {
		case 'r':
			color = "Red";
			break;
		case 'b':
			color = "Blue";
			break;
		case 'g':
			color = "Green";
			break;
		case 'y':
			color = "Yellow";
			break;
		}
		std::cout << "Current Plaring Color is:  " << color << std::endl << std::endl;
		
		if (cardDrawn == 11) {
			didSwitch = userSwapOrMove(currentPlayingColor);
		}
		if (didSwitch == false) {
			playerMovement(playerMovementInput(currentPlayingColor), cardDrawn); //Will move pieces and checks for the kills and sliders
		}
		system("pause");
		std::cout << std::endl;
		system("CLS"); //Clears screen
		//This for loop is simply here to test the game and see if it is running or not
		//Will be deleted later
		
	} while (checkIfPlayerWon(currentPlayingColor) == false);
	return currentPlayingColor;
}

int main() { //main function

	std::cout << "SORRY!" << std::endl;
	std::cout <<
		"Rules to keep in mind: \n"
		"- The pieces may only move out of the starting area if they draw a one or a two.\nThe pieces are placed in front of the start when released but cannot move by the respective individual until their next draw.\n"
		"- Pieces can pass other pieces but they cannot share a case. If a piece lands on a occupied case then they send the currently stationed piece back to the start.\n"
		"- If a player cannot follow the instruction on a card without landing on a case where one of their own piece is currently stationed, they skip their turn.\n"
		"- If a piece lands on the beginning of a slide, they move to the end of set slide sending all pieces back to their respective starting areas.\n"
		"- Safety Zones are the last five cases before the finish area.\nThese cases can only be accessed by the respective color and grant immunity to the piece from the eleven and Sorry!cards while the piece is inside of it.\n"
		"- A wrong input will result in a turn skip.\n"
		"Cards Rules:\n"
		"1 - Move a piece one forward or release a piece.\n"
		"2 - Move a piece two forward or release a piece.\nThe player can draw another card after the movement or release of a piece.\n"
		"3 - Move a piece three forward.\n"
		"4 - Move a piece four backward.\n"
		"5 - Move a piece five forward.\n"
		"7 - Move a piece seven forward.\n"
		"8 - Move a piece eight forward.\n"
		"10 - Move a piece ten forward.\n"
		"11 - Move a piece one forward or switch two pieces, one of the respective player piece with an adversary s piece.Cannot be used with pieces in the starting area.\n"
		"12 - Move a piece twelve forward.\n"
		"Sorry!- Take a piece from the respective userâ€™s starting area and replace a piece of and adversary that is currently on the board sending it back to the starting area of the adversary s respective starting area.\nThe turn is lost if there are no pieces in the respective players starting area or no available pieces for replacing.\n"
		"Rules above if you need them.\n\n\n";
	switch (gamePlayingFunction()) {
	case 'r':
		std::cout << "Red is the winner!" << std::endl;
		break;
	case 'b':
		std::cout << "Blue is the winner!" << std::endl;
		break;
	case 'g':
		std::cout << "Green is the winner!" << std::endl;
		break;
	case 'y':
		std::cout << "Yellow is the winner!" << std::endl;
		break;
	}
	system("pause");
	return 0;
}
